
*메타코딩 
https://youtu.be/hdsALpVJwgU?list=PL93mKxaRDidEfLM0I_FFb-98vfAQgXT82

1강. 설치 및 세팅

리엑트 -> ajax -> 데이터 변경 감지(옵저버패턴,트리거) -> UI가 자동 업데이트 

변경감지/UI업데이트 -> react가 해주는 일

데몬 프로세스

https://react.dev/learn/start-a-new-react-project
https://ko.legacy.reactjs.org/


npm -v
-> 라이브러리 다운 -> 빌드 -> 프로젝트 3개 (로컬에 다 다운)
-> 프로젝트마다, 글로벌 

npx  -v
-> 라이브러리 다운 -> 빌드 -> 프로젝트 3개(다운 받은 걸 재사용, 없으면 다운)
-> 실행-> 삭제
-> 

https://react.dev/learn/start-a-new-react-project

npx create-react-app my-app

npm start

eslint
prettier

format on save


2강.실행흐름 이해하기 


index.js

App.js

index.html -> root

3.기본문법 
JSX문법 - JavaScript + HTML 
React 는 하나의 태그만 리턴해준다.

4강. 배열(map, filter,slice,concat, spread연산자)

불변함수 -> 깊은 복사 함수

모듈화/컴포넌트화 

리엑트 엔진
-> 부모가 다시 그려지면 자식도 다시 그려야 될지 연산
-> 다시 그려야 되면 다시 그리고 안 그리려면 안 그린다.
-> 연산을 수행한다.
-> 깊은 복사(레퍼런스 비교만 하면 끝남)
-> 최적화를 위해 사용
-> 연산을 최적화 시켜야.
-> 자식을 다시 그려야 될지 말아야 될지 

부모 변경 -> 연산(최적화)

 //concat, filter, map, slice, 스프레드(전개) 연산자 ...

      console.log('1.====================>스프레드 연산자');
      const a = [1, 2, 3];

      const b = [...a];

      b.push(4); //b의 데이터 변경
      console.log(`a의 값은: ${a}`);
      console.log(`b의 값은: ${b}`);

      console.log('2.====================>추가하기');
      const a2 = [1, 2, 3];
      const b2 = a2.concat(4);
      console.log(`a2의 값은: ${a2}`); //1,2,3
      console.log(`b2의 값은: ${b2}`); //1,2,3,4

      const c2 = [...a, 4];
      console.log('3.====================>걸러내기'); //삭제하기

      const a1 = [0, ...a2, 4];
      console.log(`a1의 값은: ${a1}`);

      const a3 = [1, 2, 3];
      const b3 = a3.filter((n) => {
        //boolean을 return 받는다. -> true만 걸러낸다.
        console.log('n=>', n);
        return n != 1;
      });

      console.log(`b3 값은: ${b3}`);

      console.log('4.====================>잘라내기');
      a4 = [1, 2, 3];
      b4 = a4.slice(0, 2);
      console.log(b4); // [1,2]

      const c4 = [...a4.slice(0, 2)];
      console.log(c4); // [[1,2]]  <== const c4 = [a4.slice(0, 2)];

      const c5 = [...a4.slice(0, 2), 4, ...a4.slice(2, 3)];
      console.log(c5);

      console.log('5.====================>반복하기'); //반복해서 복사하기

      const a5 = [1, 2, 3];

      /*   for (let i = 0; i < a.length; i++) {
        console.log(a5[i]);
      } */
      a5.forEach((n) => {
        console.log(n);
      }); //리턴 못함.

      const b5 = a5.map((n) => n + 10); //const b5 =[...a5]

      console.log(b5);

      /////////////////////////////////////////////////////////

      react 오프라인 5강 - 배열 수정하기(map과 spread응용)


      const data = { phone: '2222' };
      const a6 = {
        id: 1,
        name: '홍길동',
        phone: '1111',
        age: 17,
        gender: '남',
      };

      //const b6 = { ...a6, name: '임꺽정' };
      const b6 = { ...a6, ...data };

      console.log('b6==>', b6);

      const users = [
        {
          id: 1,
          name: '구태모',
          phone: '2222',
        },
        {
          id: 2,
          name: '이대협',
          phone: '3333',
        },
        {
          id: 3,
          name: '오승훈',
          phone: '4444',
        },
      ];

      const updateUserDto = {
        id: 2,
        name: '홍길동',
      };

      //users[1].name = updateUserDto.name; (X)

      const newUsers = users.map((user) =>
        user.id === updateUserDto.id ? { ...user, ...updateUserDto } : user,
      ); // const newUser = {...users}

      console.log('newUsers=>', newUsers);

/////////////////////////////////////////////////////////


react 오프라인 6강 - useState

const [number, setNumber] = useState(1); //React안에 hooks 라이브러리 상태값이 됨.

  const add = () => {
    //number++;
    setNumber(number + 1); //리엑트한테 number값 변경할께 라고 요청
    console.log('add', number);
  };

  return (
    <div>
      <h1>숫자:{number}</h1>
      <button onClick={add}>더하기</button>
    </div>
  );

rsc -> react 기본 템플릿 vscode에서 
rcc -> 예전 방식 

useState(1); //React안에 hooks 라이브러리 상태값이 됨.

컴포넌트 설계를 잘해야.
op.gg

데이터가 같더라고 레퍼런스가 다르면 다시 그린다.
값도 같고 레퍼런스도 같으면 한번만 실행한다.
























